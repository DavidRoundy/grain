{
open Location
open Identifier
open Dyp
open Parsetree
open Ast_helper

let mkid ns =
  let rec help ns =
    match ns with
    | [] -> failwith "Should be impossible"
    | n::[] -> IdentName n
    | m::tl -> IdentExternal(m, (help tl)) in
  mkloc @@ help ns

let mkstr s = mkloc s (symbol_rloc())

let make_program statements body =
  {statements; body}

}

%token <int> NUM
%token <string> ID
%token <string> STRING
%token LBRACK RBRACK LPAREN RPAREN LBRACE RBRACE
%token COMMA SEMI
%token THICKARROW ARROW PIPE
%token EQEQ LESS GREATER LESSEQ GREATEREQ
%token EQUAL GETS
%token UNDERSCORE
%token COLON COLONCOLON

%token ADD1 SUB1 ISBOOL ISNUM ISTUPLE
%token PLUS MINUS TIMES
%token TRUE FALSE

%token LET REC IF ELSE MATCH
%token AND OR NOT

%token DATA IMPORT
%token EOF

%start <Parsetree.parsed_program> program

%parser

const :
  | NUM { Const.int $1 }
  | TRUE { Const.bool true }
  | FALSE { Const.bool false }
  | STRING { Const.string $1 }

prim1 :
  | ADD1 { Add1 }
  | SUB1 { Sub1 }
  | NOT { Not }
  | ISBOOL { IsBool }
  | ISNUM { IsNum }
  | ISTUPLE { IsTuple }

binop:
  | PLUS { Plus }
  | MINUS { Minus }
  | TIMES { Times }
  | EQEQ { Eq }
  | LESS { Less }
  | GREATER { Greater }
  | LESSEQ { LessEq }
  | GREATEREQ { GreaterEq }
  | AND { And }
  | OR { Or }

pattern :
  | UNDERSCORE { Pat.any() }
  | ID { Pat.var (mkstr $1) }
  | LPAREN tuple_patterns RPAREN { Pat.tuple $2 }
  | LPAREN pattern RPAREN { $2 }
  | pattern COLON typ { Pat.constraint_ $1 $3 }

patterns :
  | pattern [COMMA pattern {$2}]* { $1::$2 }

tuple_patterns :
  | pattern COMMA { [$1] }
  | pattern [COMMA pattern {$2}]+ { $1::$2 }

typ :
  /* It's a little sad that we can't do `a -> b`, but it makes sense for consistency's sake */
  | LPAREN typs RPAREN ARROW typ { Typ.arrow $2 $5 }
  | LPAREN tuple_typs RPAREN { Typ.tuple $2 }
  | LPAREN typ RPAREN { $2 }
  | typ+ id { Typ.constr $2 $1 }
  | ID { Typ.var $1 }

typs :
  | [typ [COMMA typ {$2}]* {$1::$2}]? { Option.default [] $1 }

tuple_typs :
  | typ COMMA { [$1] }
  | typ [COMMA typ {$2}]+ { $1::$2 }

value_bind :
  | pattern EQUAL binop_expr { Vb.mk $1 $3 }

value_binds :
  | value_bind [COMMA AND value_bind {$3}]* { $1::$2 }

import_stmt :
  | IMPORT id { Imp.mk $2 }

data_constructor :
  | ID { CDecl.singleton (mkstr $1) }
  | ID LPAREN typs RPAREN { CDecl.tuple (mkstr $1) $3 }

data_constructors :
  | data_constructor [PIPE data_constructor {$2}]* { $1::$2 }
  | [PIPE data_constructor {$2}]+ { $1 }

data_declaration :
  | DATA ID* ID EQUAL data_constructors { Dat.mk (mkstr $3) (List.map Typ.var $2) (PDataVariant $5) }

prim1_expr :
  | prim1 LPAREN binop_expr RPAREN { Exp.prim1 $1 $3 }

paren_expr :
  | LPAREN binop_expr RPAREN { $2 }

binop_expr :
  | expr binop expr { Exp.prim2 $2 $1 $3 }
  | expr { $1 }

app_expr :
  | expr LPAREN tuple_exprs RPAREN { Exp.apply $1 $3 }

id :
  | ID [COLONCOLON ID {$2}]* { (mkid ($1::$2)) (symbol_rloc()) }

simple_expr :
  | const { Exp.constant $1 }
  | id { Exp.ident $1 }
  | LPAREN tuple_exprs RPAREN { Exp.tuple $2 }

block_expr :
  | LBRACE block RBRACE { Exp.block $2 }

lam_expr :
  | LPAREN patterns RPAREN THICKARROW block_expr { Exp.lambda $2 $5 }

maybe_rec :
  | REC? { Option.map_default (fun _ -> Recursive) Nonrecursive $1 }

let_expr :
  | LET maybe_rec value_binds { Exp.let_ $2 $3 (Exp.block []) }

if_expr :
  | IF binop_expr block_expr { Exp.if_ $2 $3 (Exp.block []) }
  | IF binop_expr block_expr ELSE block_expr { Exp.if_ $2 $3 $5 }

expr :
  | simple_expr {$1}
  | paren_expr {$1}
  | prim1_expr {$1}
  | app_expr {$1}
  | block_expr {$1}
  | lam_expr {$1}
  | let_expr {$1}
  | if_expr {$1}

tuple_exprs :
  | binop_expr COMMA { [$1] }
  | binop_expr [COMMA binop_expr {$2}]+ { $1::$2 }

block :
  | binop_expr [SEMI binop_expr {$2}]* { $1::$2 }

toplevel_stmt :
  | LET maybe_rec value_binds { Top.let_ $2 $3 }
  | import_stmt { Top.import $1 }
  | data_declaration { Top.data $1 }

toplevel_stmts :
  | toplevel_stmt [SEMI toplevel_stmt {$2}]* { $1::$2 }

program :
  | toplevel_stmts SEMI EOF { make_program $1 (Exp.null ~loc:dummy_loc ()) }
  | toplevel_stmts SEMI binop_expr EOF { make_program $1 $3 }
